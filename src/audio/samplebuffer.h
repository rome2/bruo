////////////////////////////////////////////////////////////////////////////////
// (c) 2013 Rolf Meyerhoff. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
///\file    samplebuffer.h
///\ingroup bruo
///\brief   Sample buffer include file.
///\author  Rolf Meyerhoff (badlantic@gmail.com)
///\version 1.0
/// This file is part of the bruo audio editor.
////////////////////////////////////////////////////////////////////////////////
///\par License:
/// This program is free software: you can redistribute it and/or modify it
/// under the terms of the GNU General Public License as published by the Free
/// Software Foundation, either version 2 of the License, or (at your option)
/// any later version.
///\par
/// This program is distributed in the hope that it will be useful, but WITHOUT
/// ANY WARRANTY; without even  the implied warranty of MERCHANTABILITY or
/// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
/// more details.
///\par
/// You should have received a copy of the GNU General Public License along with
/// this program; see the file COPYING. If not, see http://www.gnu.org/licenses/
/// or write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
/// Floor, Boston, MA 02110-1301, USA.
////////////////////////////////////////////////////////////////////////////////
#ifndef __SAMPLEBUFFER_H_INCLUDED__
#define __SAMPLEBUFFER_H_INCLUDED__

////////////////////////////////////////////////////////////////////////////////
///\class   SampleBuffer samplebuffer.h
///\brief   Buffer for samples.
///\remarks This class encapsulates a sample buffer. The sample format is double
///         precision float, normalized to [-1, 1]. For performance reasons this
///         class should not be derived.
////////////////////////////////////////////////////////////////////////////////
class SampleBuffer
{
public:
  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::SampleBuffer()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Default constructor of this class.
  ///\remarks Basically only initializes the buffer.
  //////////////////////////////////////////////////////////////////////////////
  SampleBuffer();

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::SampleBuffer()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Copy constructor of this class.
  ///\brief   [in] other: The buffer to copy.
  ///\remarks Copies the entire buffer.
  //////////////////////////////////////////////////////////////////////////////
  SampleBuffer(const SampleBuffer& other);

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::SampleBuffer()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Initialization constructor of this class.
  ///\brief   [in] numChannels: Number of channels of this buffer.
  ///\param   [in] numSamples:  Number of samples for a single channel.
  ///\remarks The buffer is zeroed.
  //////////////////////////////////////////////////////////////////////////////
  SampleBuffer(int numChannels, int numSamples);

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::~SampleBuffer()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Default destructor of this class.
  ///\remarks Frees all used resources. This is not virtual because this class
  ///         is not ment to be subclassed.
  //////////////////////////////////////////////////////////////////////////////
  ~SampleBuffer();

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::channelCount()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Access the number of channels of this buffer.
  ///\return  The number of channels of this buffer.
  ///\remarks 1 is mono, 2 is stereo etc.
  //////////////////////////////////////////////////////////////////////////////
  int channelCount() const;

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::sampleCount()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Access the sample count of this buffer.
  ///\return  The sample count.
  ///\remarks Samples are only counted for a single channel here so for the
  ///         count it doesn't matter how many channels there are.
  //////////////////////////////////////////////////////////////////////////////
  int sampleCount() const;

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::sampleBuffer()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Access the samples of this buffer.
  ///\param   [in] channel: The channel to access.
  ///\return  A pointer to the first sample of the requested channel.
  ///\remarks The data is not interleaved so each channel has it's own buffer.
  //////////////////////////////////////////////////////////////////////////////
  double* sampleBuffer(const int channel);

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::sampleBuffer()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Access the samples of this buffer, const version.
  ///\param   [in] channel: The channel to access.
  ///\return  A pointer to the first sample of the requested channel.
  ///\remarks The data is not interleaved so each channel has it's own buffer.
  //////////////////////////////////////////////////////////////////////////////
  const double* sampleBuffer(const int channel) const;

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::sample()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief  Extract a single sample from this buffer.
  ///\param  [in] channel: The channel of the sample.
  ///\param  [in] sample:  The index of the sample.
  ///\return The requested sample.
  //////////////////////////////////////////////////////////////////////////////
  double sample(const int channel, const int sample) const;

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::setSample()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief  Set a single sample from this buffer.
  ///\param  [in] channel: The channel of the sample.
  ///\param  [in] sample:  The index of the sample.
  ///\param  [in] value:   The new sample.
  //////////////////////////////////////////////////////////////////////////////
  void setSample(const int channel, const int sample, const double value);

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::makeSilence()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief Fill this buffer with zeroes.
  //////////////////////////////////////////////////////////////////////////////
  void makeSilence();

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::operator = ()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Assignment operator of this class.
  ///\brief   [in] other: The buffer to copy.
  ///\return  A reference to this object.
  ///\remarks Copies the entire buffer without allocations if possible.
  //////////////////////////////////////////////////////////////////////////////
  SampleBuffer& operator = (const SampleBuffer& other);

  //////////////////////////////////////////////////////////////////////////////
  // SampleBuffer::createBuffers()
  //////////////////////////////////////////////////////////////////////////////
  ///\brief   Create the actual storage space for this buffer.
  ///\brief   [in] numChannels: Number of channels of the buffer.
  ///\param   [in] numSamples:  Number of samples for a single channel.
  ///\remarks The old buffer (if any) will be deleted and the new buffer is
  ///         zeroed.
  //////////////////////////////////////////////////////////////////////////////
  void createBuffers(int numChannels, int numSamples);

private:

  //////////////////////////////////////////////////////////////////////////////
  // Member:
  int     m_channelCount; ///> Number of channels.
  int     m_sampleCount;  ///> Number of samples of a channel.
  double* m_sampleBuffer; ///> Pointer to the channel buffers.
};

#endif // #ifndef __SAMPLEBUFFER_H_INCLUDED__
///////////////////////////////// End of File //////////////////////////////////
